"""
GPT-powered waypoint generator for intelligent route planning.

This module uses GPT-5 nano to analyze user preferences and generate
contextually aware waypoints that are then used by GraphHopper for
actual route generation.
"""

import asyncio
import json
import os
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass

import openai
from .logger import get_logger
from .models import FrontendRoutePreferences
from .config import get_openai_api_key, get_openai_base_url, get_openai_model

# =============================================================================
# DATA MODELS
# =============================================================================

@dataclass
class GPTWaypoint:
    """A waypoint generated by GPT with context and reasoning."""
    
    lat: float
    lon: float
    name: str
    description: str
    reasoning: str
    category: str  # e.g., "scenic", "historical", "restaurant", "park"
    estimated_duration_minutes: Optional[int] = None

@dataclass
class GPTRoutePlan:
    """Complete route plan generated by GPT."""
    
    waypoints: List[GPTWaypoint]
    total_estimated_distance_km: float
    route_description: str
    highlights: List[str]
    recommendations: List[str]
    estimated_total_duration_minutes: int

# =============================================================================
# GPT WAYPOINT GENERATOR CLASS
# =============================================================================

class GPTWaypointGenerator:
    """
    GPT-powered waypoint generator that creates intelligent routes.
    
    This generator:
    1. Analyzes user preferences using GPT-5 nano
    2. Generates contextually aware waypoints
    3. Provides reasoning for each waypoint choice
    4. Creates a cohesive route narrative
    """
    
    def __init__(self):
        self.logger = get_logger(__name__)
        # For OpenAI v0.28.1, we don't need to initialize a client
        # We'll set the API key and base URL when making calls
        self.model = get_openai_model()  # Can be overridden to GPT-5 nano via environment
        
    async def generate_intelligent_route(self, preferences: FrontendRoutePreferences) -> GPTRoutePlan:
        """
        Generate an intelligent route using GPT based on user preferences.
        
        Args:
            preferences: User route preferences from frontend
            
        Returns:
            GPTRoutePlan with intelligent waypoints and route narrative
        """
        try:
            self.logger.info(f"=== GENERATING GPT-POWERED ROUTE ===")
            self.logger.info(f"Preferences: {preferences.distanceTarget} miles, {preferences.elevationTarget} ft, {preferences.routeType}")
            
            # Extract coordinates
            start_lat = preferences.startingPointCoords["lat"]
            start_lon = preferences.startingPointCoords["lng"]
            
            # Create GPT prompt
            prompt = self._create_route_prompt(preferences, start_lat, start_lon)
            
            # Generate route with GPT
            gpt_response = await self._call_gpt(prompt)
            
            # Parse GPT response
            route_plan = self._parse_gpt_response(gpt_response, start_lat, start_lon)
            
            self.logger.info(f"GPT generated {len(route_plan.waypoints)} intelligent waypoints")
            self.logger.info(f"Estimated distance: {route_plan.total_estimated_distance_km:.2f}km")
            
            return route_plan
            
        except Exception as e:
            self.logger.error(f"GPT route generation failed: {e}", exc_info=True)
            # Fallback to basic waypoints
            return self._generate_fallback_route(preferences, start_lat, start_lon)
    
    def _create_route_prompt(self, preferences: FrontendRoutePreferences, start_lat: float, start_lon: float) -> str:
        """Create a comprehensive prompt for GPT route generation."""
        
        prompt = f"""
You are an expert cycling route planner. Create an intelligent, engaging route based on these preferences:

**Starting Location**: {start_lat}, {start_lon} (Philadelphia area)
**Target Distance**: {preferences.distanceTarget} miles
**Elevation Target**: {preferences.elevationTarget} feet
**Route Type**: {preferences.routeType}
**Preferences**: 
- Bike lanes: {preferences.bikeLanes}
- Prefer greenways: {preferences.preferGreenways}
- Avoid high traffic: {preferences.avoidHighTraffic}
- Include scenic routes: {preferences.includeScenic}
- Points of interest: {preferences.pointsOfInterest}

**Requirements**:
1. Generate 5-8 waypoints that create an engaging route
2. Each waypoint should have a purpose (scenic view, historical site, park, restaurant, etc.)
3. Consider the user's preferences for bike lanes, greenways, and avoiding traffic
4. Ensure the total route distance is close to {preferences.distanceTarget} miles
5. Include elevation variation to meet the {preferences.elevationTarget} ft target
6. Make the route interesting and varied

**Output Format** (JSON):
{{
    "waypoints": [
        {{
            "name": "Waypoint name",
            "description": "What makes this point interesting",
            "reasoning": "Why this waypoint was chosen",
            "category": "scenic|historical|park|restaurant|viewpoint|landmark",
            "estimated_duration_minutes": 15,
            "lat": 39.9526,
            "lon": -75.1652
        }}
    ],
    "route_description": "Overall route narrative",
    "highlights": ["Key highlights of the route"],
    "recommendations": ["Cycling tips and recommendations"],
    "total_estimated_distance_km": 25.0,
    "estimated_total_duration_minutes": 120
}}

**Important**: 
- Return ONLY valid JSON
- Use realistic coordinates near Philadelphia
- Ensure waypoints form a logical route progression
- Make the route engaging and varied
- Consider seasonal factors and local attractions
"""
        
        return prompt.strip()
    
    async def _call_gpt(self, prompt: str) -> str:
        """Call GPT API to generate route."""
        try:
            self.logger.info("Calling GPT API for route generation...")
            
            # Set the API key for this request
            openai.api_key = get_openai_api_key()
            openai.api_base = get_openai_base_url()
            
            # GPT-5 nano only supports default temperature (1.0)
            response_params = {
                "model": self.model,
                "messages": [
                    {
                        "role": "system",
                        "content": "You are an expert cycling route planner. Always respond with valid JSON."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "max_completion_tokens": 2000
            }
            
            # Only add temperature for models that support it
            if not self.model.startswith("gpt-5"):
                response_params["temperature"] = 0.7
            
            response = openai.ChatCompletion.create(**response_params)
            
            gpt_response = response.choices[0].message.content
            self.logger.info("GPT API call successful")
            
            return gpt_response
            
        except Exception as e:
            self.logger.error(f"GPT API call failed: {e}")
            raise
    
    def _parse_gpt_response(self, gpt_response: str, start_lat: float, start_lon: float) -> GPTRoutePlan:
        """Parse GPT response into structured route plan."""
        try:
            # Parse JSON response
            data = json.loads(gpt_response)
            
            # Validate and create waypoints
            waypoints = []
            for wp_data in data.get("waypoints", []):
                waypoint = GPTWaypoint(
                    lat=float(wp_data["lat"]),
                    lon=float(wp_data["lon"]),
                    name=wp_data["name"],
                    description=wp_data["description"],
                    reasoning=wp_data["reasoning"],
                    category=wp_data["category"],
                    estimated_duration_minutes=wp_data.get("estimated_duration_minutes")
                )
                waypoints.append(waypoint)
            
            # Create route plan
            route_plan = GPTRoutePlan(
                waypoints=waypoints,
                total_estimated_distance_km=float(data.get("total_estimated_distance_km", 0)),
                route_description=data.get("route_description", ""),
                highlights=data.get("highlights", []),
                recommendations=data.get("recommendations", []),
                estimated_total_duration_minutes=int(data.get("estimated_total_duration_minutes", 0))
            )
            
            return route_plan
            
        except Exception as e:
            self.logger.error(f"Failed to parse GPT response: {e}")
            self.logger.error(f"GPT response: {gpt_response}")
            raise ValueError(f"Invalid GPT response format: {e}")
    
    def _generate_fallback_route(self, preferences: FrontendRoutePreferences, start_lat: float, start_lon: float) -> GPTRoutePlan:
        """Generate a fallback route if GPT fails."""
        self.logger.info("Generating fallback route due to GPT failure")
        
        # Simple fallback waypoints around Philadelphia
        fallback_waypoints = [
            GPTWaypoint(
                lat=start_lat,
                lon=start_lon,
                name="Starting Point",
                description="Your starting location",
                reasoning="Fallback starting point",
                category="start"
            ),
            GPTWaypoint(
                lat=start_lat + 0.01,
                lon=start_lon + 0.01,
                name="Scenic Overlook",
                description="Nice view of the city",
                reasoning="Fallback scenic point",
                category="scenic"
            ),
            GPTWaypoint(
                lat=start_lat - 0.01,
                lon=start_lon + 0.02,
                name="Park Stop",
                description="Green space for rest",
                reasoning="Fallback rest point",
                category="park"
            ),
            GPTWaypoint(
                lat=start_lat,
                lon=start_lon,
                name="Return Point",
                description="Back to start",
                reasoning="Fallback return point",
                category="end"
            )
        ]
        
        return GPTRoutePlan(
            waypoints=fallback_waypoints,
            total_estimated_distance_km=preferences.distanceTarget * 1.60934,
            route_description="Fallback route generated due to GPT unavailability",
            highlights=["Basic route with fallback waypoints"],
            recommendations=["Route generated using fallback system"],
            estimated_total_duration_minutes=60
        )
    
    def get_waypoint_coordinates(self, route_plan: GPTRoutePlan) -> List[Tuple[float, float]]:
        """Extract coordinate tuples from GPT waypoints for GraphHopper."""
        return [(wp.lat, wp.lon) for wp in route_plan.waypoints]
    
    def get_route_metadata(self, route_plan: GPTRoutePlan) -> Dict:
        """Extract metadata from GPT route plan."""
        return {
            "gpt_generated": True,
            "route_description": route_plan.route_description,
            "highlights": route_plan.highlights,
            "recommendations": route_plan.recommendations,
            "waypoint_categories": [wp.category for wp in route_plan.waypoints],
            "estimated_total_duration_minutes": route_plan.estimated_total_duration_minutes
        } 